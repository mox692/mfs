

手順
* step1
  * filenameとdataをセットにして、dbに保存できる
  * filenameをkeyにして取得できる

  * 課題
    * 書き込み or 読み込みの際に、1つのfileしかないので、そこが必ずlockされてしまう
    * ファイルの内容を変更した時に、他のファイルの位置も移動させて上げないといけない

## アーキテクチャ考察
* ハッシュマップでもいいのでは？という疑問に対する反論
  * まず、衝突しないようにするのが結構むずそう
    * ~~最大10文字のアルファベットだけに制限したとしても、 23 * 23 * 23 ... = 2^10 = 41,426,511,213,649通りの配列が必要?~~
      * いや、hashmap確か拡張できたわ.
    * 1つのkeyに対するvalueの大きさが推定できない気がする.
      * valueに階層を持たせた構造だったら大した問題にならないかも
      * valueに(メタデータではなく、)そのままデータを載せてるような仕組みだとキツそう.
    * こう考えると、「hashmapではだめ？」というより、作ろうとしてるものは「hashmapの延長」という方が適切な気がしてきた
    * 大事なのは、valueにどういうdata構造を持たせるか、という話かな？
  * hashmapの仕組み上、hash関数が必要になるんだけどそれをどこに保存する?
    * まあこれはなんとかなるはず
* メタデータの管理手法
  * hashmap
    * ファイル名をkeyとしたhashmapで持っておく
    * pros
      * (主にarrayと比較して)高速な検索、追加、削除
    * cons
      * 必要なメモリがやや大きくなる(ただごさかな？)
        * 
  * sortされた配列
    * 一定の大きさのmetadata構造体の配列として持っておく
    * 配列はファイル名とかでソートして置く
    * pros
      * (主にhashmapと比較して)必要なメモリは少なくて済む
    * cons
      * ファイルを追加・削除した時に、既存のmetadataの配列sortし直す必要がある 

## バージョン
### v1
* ファイル名を指定して、そのファイルに格納されているデータ(byte列)を返す
* ディスク全体を固定のblockサイズに分ける(1block 1000byte)
* 1ファイル = 1blockにする(つまり最大文字数が定義されている (1000byte))
* hash tableのデータ構造は↓の感じ
```
map[key] {
  block_index: int
}
```
* block_index(現在のファイル数)はどこかで管理して置く.
* 新しくファイルを作成する際に、block_index
* 1000byteより大きいデータはかけないw ので、続きに書いてもらう

## 使い方
```rust
let storage = malloc(1000)
let fs = FS::new(storage); // storageを引数にとる
let content = get_content(&mut io::stdin())?;
```

## 作業日報
4/23
* とりあえずstorageのinterfaceを書く


